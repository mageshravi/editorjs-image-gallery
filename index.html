<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EditorJS Tryout</title>
    <link rel="stylesheet" href="./static/css/dist/style.css">
</head>
<body>
    <div style="margin: 0 auto; max-width: 650px">
        <label for="codex-editor-input"><strong>Input</strong></label><br>
        <textarea
            name="codex_ediotor_input" 
            id="codex-editor-input" 
            cols="80" rows="10"
        >{"time":1585813330356,"blocks":[{"type":"heading","data":{"text":"Notes PWA","level":1}},{"type":"heading","data":{"text":"Objective","level":2}},{"type":"paragraph","data":{"text":"A note-taking app that is,<br>"}},{"type":"list","data":{"style":"ordered","items":["<b>Cross-platform</b> - should work on iOS, Android, Windows, Mac and Linux.","<b>Installable</b> - should feel like a native app and be accessible from outside the web browser.","<b>Offline compatible</b> - should work even in poor conditions.","<b>Open</b> - all notes must be publicly accessible.","<b>Easy to share</b> - every note should have a unique URL for sharing.<br>"]}},{"type":"heading","data":{"text":"Responsibilities","level":2}},{"type":"paragraph","data":{"text":"We were to analyze the requirements, choose the right technology stack, design, develop and maintain the application."}},{"type":"paragraph","data":{"text":"#ProductDesign #UIDesign #SoftwareArchitecture #SoftwareEngineering"}},{"type":"heading","data":{"text":"The Approach","level":2}},{"type":"paragraph","data":{"text":"As with any project, we started with the why. With clearly defined objectives, making decisions became easy. Some big decisions we made along the way are,"}},{"type":"list","data":{"style":"ordered","items":["Build once, deploy anywhere - Reduce the skill set required development and maintenance of the application.","No wrappers like PhoneGap or Ionic - They require an additional skill set or introduce a learning curve. Also, we didn't want to go through the Apple/Google app store submission.<br>","Progressive Web Apps (PWA) - They fit the requirements perfectly. With just HTML and JavaScript, we could create an app with near-native user experience using service workers, local storage and push notifications. PWA's did involve a minor learning curve, but the components were all part of the standard HTML5 APIs. We chose to learn something that was part of the standard APIs instead of third-party ones.","Python/Django - The application had just one role - the admin user who'll add/edit notes. For this reason, we didn't want to code the admin panel from scratch. So, we started looking for admin modules that were easy to configure. We knew the Django framework had the best admin panel functionality out of the box.<br>"]}},{"type":"heading","data":{"text":"How we implemented offline compatibility?","level":2}},{"type":"paragraph","data":{"text":"The service worker makes offline compatibility possible. It acts as a proxy between the client (browser) and the server deciding the routes for each request."}},{"type":"paragraph","data":{"text":"During the first run i.e., installation/activation phase, the service worker,"}},{"type":"list","data":{"style":"ordered","items":["Fetches and stores the static assets for the application from (like HTML, CSS, images and JS) in the browser cache.","Fetches and stores the notes data as JSON strings in the IndexedDB."]}},{"type":"paragraph","data":{"text":"After activation, for successive HTTP(S) requests, the service worker does one or more of the following."}},{"type":"list","data":{"style":"ordered","items":["If the request is for a static asset cached in the browser, then the service worker responds with data directly from the cache. In such a case, the request never reaches the server.","Requests for static assets could specify a \"no-cache\" parameter. In such cases, the service worker disregards the data in the cache and forwards the request to the server. If the response from the server is successful, then the cached data is updated with the new response.","The service worker remains invisible to all other requests i.e. their request or response is not affected in any way.<br>"]}},{"type":"paragraph","data":{"text":"The caching strategy described above is known as \"cache-only\" and is useful for content that changes very rarely (static assets)."}},{"type":"paragraph","data":{"text":"In the business logic, whenever we need new JSON data like notes, folders or tags, we send out two requests - one directed at IndexedDB and the other towards the server. Then depending on the speed of response, one of the following happens."}},{"type":"list","data":{"style":"ordered","items":["IndexedDB responds faster than the server. As a result, the view is rendered almost instantly with the data from IndexedDB. Subsequently, when the response from the server reaches the client, we refresh the view to display the latest information.&nbsp;","The server responds faster than IndexedDB. In this rare condition, the view is rendered with data from the server first. Later, upon receiving a response from IndexedDB, we compare the timestamps to display the latest information.","The server is not reachable, does not respond or responds with an error. In this offline condition, the user will still see data stored in the IndexedDB."]}},{"type":"paragraph","data":{"text":"The caching strategy described above is known as \"cache-then-network\" useful for dynamic content that has to be up-to-date (JSON data)."}},{"type":"heading","data":{"text":"Push notifications","level":2}},{"type":"list","data":{"style":"ordered","items":["Whenever the admin user creates or updates a folder, tag or note, we send out push notifications using Django signals and WebPushNotification API.","The service worker receives the notification, then passes the information onto the client. The client then starts synchronizing the data depending on the type of notification received.&nbsp;","However, letting clients synchronize data has a disadvantage. Let's assume the user has multiple tabs open in their browser. In such a case, every tab/window acting as a client for the service worker will start synchronizing data and increase network &amp; memory consumption. The service worker solves this by signalling only the first tab or window and ignoring the rest."]}},{"type":"heading","data":{"text":"Screenshots","level":2}},{"type":"gallery","data":{"images":[{"url":"https://placeimg.com/148/148/animals"},{"url":"https://placeimg.com/148/148/arch"},{"url":"https://placeimg.com/148/148/nature"},{"url":"https://placeimg.com/148/148/tech"}]}},{"type":"heading","data":{"text":"Skills","level":2}},{"type":"paragraph","data":{"text":"HTML5, CSS, JavaScript ES6, VueJS, IndexedDB, ServiceWorkers, WebPushNotifications, Python, Django, PostgreSQL, Docker and Nginx."}},{"type":"heading","data":{"text":"Tools used","level":2}},{"type":"paragraph","data":{"text":"Figma, Visual Studio Code and Github."}},{"type":"heading","data":{"text":"Project duration","level":2}},{"type":"paragraph","data":{"text":"From idea to MVP - three weeks"}},{"type":"heading","data":{"text":"Call to action","level":2}},{"type":"paragraph","data":{"text":"We could develop a similar project for you for Rs. X in Y days.<br>"}}],"version":"2.17.0"}</textarea>
        <button id="load" type="button">Load</button><br>
        <br>

        <div id="codex-editor"></div>
        <button id="my-btn" type="button">Save</button><br>
        <br>

        <label for="codex-editor-textarea"><strong>Output</strong></label><br>
        <textarea name="codex_editor_output" readonly id="codex-editor-textarea" cols="80" rows="10"></textarea>
        <script type="text/javascript" src="./static/js/dist/index.js"></script>
    </div>
</body>
</html>
